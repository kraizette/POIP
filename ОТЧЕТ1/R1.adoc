:imagesdir: R1IM
= Отчет по лабораторной работе №1

== Задание 1

*  Создать проект C++ c main.cpp

Для создания проекта мы используем интегрируемую среду разработки IAR Embedded Workbench

Project>Create New Project...

.создание нового проекта
image::Screenshot4.png[]

Выбираем язык C++ и глобальную функцию main

.настройки новго проекта
image::Screenshot5.png[]

Сохраним проект под каким-либо именем
В свойствах проекта выбираем модель микроконтроллера ST => STM32F4=> STM32F411=> ST STM32F411RE. Для этого правой кнопкой мыши щелкнуть по проекту, выбирать Options
и далее в категории General Option выбрать закладку Target.

.выбор микроконтроллера
image::Figure11.png[]

Наш проект выглядит так:

.стартовый вид проекта
image::Figure12.png[]

*  Подключить к проекту файл cstartup.cpp

Для подключения файла cstartup.cpp, потребовалось его скачать. Для этого клонируем папку проекта преподавателя, набрав в командной строке:

----
git clone https://github.com/lamer0k/CortexLib.git
----

.клонирование папки через командную строку
image::Screenshot6.png[]

Путь к папке в данном случае C:\Users\User

В папке находим файл cstartup.cpp.Добавим его к проекту:

Для этого нужно нажать правую кнопку мыши на проекте и выбрав пункт Add=>Add Files…, а затем выбрать файл startup_stm32F411.cpp.

[#Добавление новых файлов]
.добавление нового файла
image::Figure15.png[]


* Создать папки AbstractHardware/Registers/FiledValues, Common, Application, FreeRtos

Данные папки требуется создать в папке, кеуда был сохранен проект. Так же их можно скопировать с клонированной папки преподавателя.

.структура после добавления папок
image::Screenshot7.png[]

* Создать структуру проекта в соответствии со структурой папок

Теперь необходимо создать точно такую же структуру в проекте IAR Workbench, как и структура папок.
Для этого необходимо нажать правой мышкой на проект, и выбрать меню Add=>Ggroup и создать группы
Abstract_Hardware, Application, Common, FreeRtos.

.Изменение структуры проекта
image::Figure19.png[]

Поочередно добавляем все папки сохраняя их иерархическую структуру.


В конечном итоге у вас должна появиться вот такая структура:

.Финальная структура проекта
image::Figure20.png[400, 400]


* Настроить STACK, HEAP

Для включения  анализа глубины стека достаточно поставить галочку в меню Option=>Linker=>Advanced=>Enable stack usage analysis

[#Анализ стека]
.Опция анализа глубины стека
image::Figure24.png[400, 400]


* Скопировать содержимое папки Registers и Common с проекта преподавателя в свою папку

Поочередно добавляем все файлы (см. <<Добавление новых файлов>>) сохраняя их иерархическую структуру.

* Написать программу в main.cpp

Скопировали код программы с файла преподавателя.

[source]

----
#include "gpiocregisters.hpp" //for GPIOC
#include "rccregisters.hpp"   //for RCC

int main()
{
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::ODR::ODR5::Enable::Set() ;
  GPIOC::ODR::ODR5::Disable::Set() ;
  return 0 ;
}
----

Во время компиляции возникли ошибки.
Это было связанно с тем, что в файлах *gpiocfieldvalues.hpp* и *rccfieldvalues.hpp* значения регистра  *ODR5* были прописаны как Value1, Value0, а не Enable, Outputy.

image::Screenshot8.png[]
image::Screenshot9.png[]

Для устранения ошибки исправим значения на нужные:

image::Screenshot11.png[]
image::Screenshot10.png[]
image::Screenshot12.png[]

Сохраним изменения. Компиляция прошла успешно.

====
UPD:  переписала код с последовательно мигающими лампочками на понятные значения.

[source]
----
#include "gpioaregisters.hpp"
#include "gpiocregisters.hpp" //
#include "rccregisters.hpp"

int main()
{
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;

  
  GPIOA::ODR::ODR5::Enable::Set() ;
  GPIOC::ODR::ODR9::Enable::Set() ;
  GPIOC::ODR::ODR8::Enable::Set() ;
  GPIOC::ODR::ODR5::Enable::Set() ;
  
  GPIOA::ODR::ODR5::Disable::Set() ; 
  GPIOC::ODR::ODR9::Disable::Set() ;
  GPIOC::ODR::ODR8::Disable::Set() ;
  GPIOC::ODR::ODR5::Disable::Set() ;
  return 0;
}
----
Компиляция прошла успешно. Диодики мигают.
====

== Задание 2

Следующим шагом является прошивка программы в микроконтроллер.

Для начала производили отладку в симуляторе для проверки работоспособности программы.

* Откомпилировать и отлинковать программу

Для компиляции без загрузки в симулятор можно воспользоваться командой make

image::Screenshot15.png[]
Ошибок не возникло

* Загрузить программу в симуляторе

Для запуска в симуляторе используем:

image::Screenshot16.png[]
или горячие клавиши *"Ctrl+D"*

* Сделать пошаговую отладку

Пошаговая отладка выполняется кнопками:

image::Screenshot17.png[]
или *F10*, *F11*, *F12* соответственно.

* Настроить Debugger на отладку через StLink

Для настройки идем в Project=>Options...=>ST-LINK и выбираем параметры как показано на рисунке ниже

.параметры ST-LINK
image::Screenshot18.png[]

* Подключить плату к компьютеру

Подключаем плату к компьютеру через USB порт.

[red]#При скачивании IAR должны быть установлены все необходимые драйвера, в противном случае программа не увидит плату#

* Загрузить программу в плату

Загружаем программу в плату кнопками *Ctrl+D*.
Возможно столкнуться с ошибкой:

image::Screenshot13.png[]

Решим ее, задав путь к своему файлу *startup.cpp*:

image::Screenshot14.png[]

Теперь выполняем отладку не через симулятор, а в плате.

* Выполнить пошаговую отладку

Пошаговую отладку выполняем клавишей *F10*

* Описать полученный результат

Код программы с построчным описанием:
[source, cpp, linenums]
----
#include "gpioaregisters.hpp" //for Gpioa
#include "gpiocregisters.hpp" //for Gpioс
#include "rccregisters.hpp" //for RCC

int main() //глобальная функция main
//тело функции
{ 
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ; //разрешение тактирования порта А
  GPIOA::MODER::MODER5::Output::Set() ;//PA_5 - выход
  
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ; //разрешение тактирования порта С
  GPIOC::MODER::MODER9::Output::Set() ; //PС_9 - выход
  GPIOC::MODER::MODER8::Output::Set() ; //PС_8 - выход
  GPIOC::MODER::MODER5::Output::Set() ; //PС_5 - выход

  
  GPIOA::ODR::ODR5::Enable::Set() ; //включение диода PA_5 
  GPIOC::ODR::ODR9::Enable::Set() ; //включение диода PС_9
  GPIOC::ODR::ODR8::Enable::Set() ; //включение диода PС_8
  GPIOC::ODR::ODR5::Enable::Set() ; //включение диода PС_5
  
  GPIOA::ODR::ODR5::Disable::Set() ; //выключение диода PA_5
  GPIOC::ODR::ODR9::Disable::Set() ; //выключение диода PС_9
  GPIOC::ODR::ODR8::Disable::Set() ; //выключение диода PС_8
  GPIOC::ODR::ODR5::Disable::Set() ; //выключение диода PС_5
  return 0; //заканчивает выполнение функции и возвращает в 0
}
----
Результат работы:

video::364375916[vimeo]



== Задание 3

Следующим заданием являлось работа с организацией памяти, настройкой стека и кучи.
При неверной настройке данных параметров программа может не выполняться.
Так же грамотная настройка позволит нам сократить вес итоговой программы.

* Запустить анализатор стека. Узнать рекомендуемый размер стека.

При настройке мы включили анализ стека.(см. <<Анализ стека>>)
Рекомендуемый размер стека мы можем посмотреть в .map файле.
Рекомендуемый размер стека: 16

image::Screenshot1.png[]

* Изменить в проекте размер стека на рекомендуемый

Изменим в проекте размер стека на рекомендуемый

image::Screenshot2.png[]

* Описать что написано в map файле

В .map файле написаны размеры составляющих проекта
Мы можем увидеть размер стека

image::Screenshot19.png[]

Размер отдельных элементов:

image::Screenshot20.png[]

Размер нашего файла:

image::Screenshot3.png[]

* Поставить размер кучи HEAP в 0. Объяснить почему так можно сделать. И почему STACK нельзя

Размер кучи HEAP можно поставить в 0, т.к. не используется динамическая память. Размер STACK нельзя поставить в 0, т.к. при использовании функций будет невозможна запись адреса возврата. 
Однако, в нашем случае, путем эксперимента было установлено, что даже при выставлении 0 в стеке программа запускается и диоды мигают.

* Добавить проект в Git и сделать синхронизацию с GitHub [green]#icon:check[]#
* Сделать отчет по каждому пункту каждого задания в файле .adoc. Выложить файл в GitHub [green]#icon:check[]#
* Прислать ссылку на GitHub преподавателю для проверки [green]#icon:check[]#
 
